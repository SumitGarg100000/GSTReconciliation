<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GST Reconciliation Tool</title>

<style>
    /* Simple CSS Reset */
    * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        font-size: 100%;
        font-family: inherit;
    }

    body {
        font-family: 'Segoe UI', Arial, sans-serif;
        margin: 0;
        padding: 30px;
        background: linear-gradient(135deg, #e0f7fa, #b2ebf2);
        color: #333;
    }

    .container {
        max-width: 1300px;
        margin: 0 auto;
        background: #fff;
        padding: 30px;
        border-radius: 15px;
        box-shadow: 0 8px 20px rgba(0, 0, 0, 0.1);
    }

    h1 {
        text-align: center;
        color: #00796b;
        font-size: 2.5em;
        margin-bottom: 20px;
        text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.1);
    }

    h2 {
        text-align: center;
        color: #004d40;
        font-size: 1.8em;
        margin: 20px 0;
    }

    .upload-section, .input-section {
        display: flex;
        justify-content: center;
        align-items: center;
        margin: 20px 0;
        gap: 20px;
    }

    .upload-section div, .input-section div {
        display: flex;
        flex-direction: column;
        gap: 10px;
    }

    label {
        font-weight: bold;
        color: #00695c;
    }

    input[type="file"], input[type="number"] {
        padding: 10px;
        border: 2px solid #26a69a;
        border-radius: 5px;
        background: #f1f8e9;
        transition: border-color 0.3s;
        font-size: 1em; /* Ensure the font size matches the rest of the content */
    }

    input[type="file"]:hover, input[type="number"]:hover {
        border-color: #00796b;
    }

    .data-container {
        margin: 30px 0;
    }

    .table-container {
        overflow-x: auto;
        margin: 10px 0;
        border: 1px solid #b0bec5;
        border-radius: 8px;
        padding: 15px;
        background: #fafafa;
        box-shadow: 0 4px 10px rgba(0, 0, 0, 0.05);
    }

    table {
        width: 100%;
        border-collapse: collapse;
        font-size: 14px; /* Base font size for tables */
    }

    th, td {
        border: 1px solid #cfd8dc;
        padding: 12px;
        text-align: left;
        font-size: 14px; /* Base font size for all cells */
    }

    th {
        background: #e0ffff; /* Light Cyan for headings */
        color: #004d40;
        font-weight: bold;
    }

    button {
        display: block;
        margin: 30px auto;
        padding: 12px 30px;
        background: linear-gradient(45deg, #26a69a, #00796b);
        color: white;
        border: none;
        border-radius: 25px;
        cursor: pointer;
        font-size: 1.1em;
        transition: transform 0.2s, box-shadow 0.2s;
    }

    button:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 15px rgba(0, 0, 0, 0.2);
    }

    a#download-sample, a#download-output {
        display: block;
        text-align: center;
        margin: 20px auto;
        color: #00796b;
        text-decoration: none;
        font-weight: bold;
        transition: color 0.3s;
    }

    a#download-sample:hover, a#download-output:hover {
        color: #004d40;
    }

    .match-gstn-inv-date { background-color: #00ced1; color: white; } /* Teal */
    .match-inv { background-color: #4b0082; color: white; } /* Indigo */
    .match-gstn-date { background-color: #32cd32; color: white; } /* Lime Green */
    .match-gstn { background-color: #ffbf00; } /* Amber */
    .gstn-not-match { background-color: #dc143c; color: white; } /* Crimson */
    .no-match { background-color: #ff00ff; color: white; } /* Magenta */

    /* Default font size for contenteditable fields and summary container (Desktop view) */
    [contenteditable="true"],
    [contenteditable="true"] * {
        font-size: 9px !important; /* 9px for desktop */
    }

    #summary-container table th,
    #summary-container table td,
    #summary-container table th *,
    #summary-container table td * {
        font-size: 9px !important; /* 9px for desktop */
    }

    /* Media query for mobile view (â‰¤ 768px) */
    @media (max-width: 768px) {
        .upload-section, .input-section {
            flex-direction: column;
        }
        .container {
            padding: 20px;
        }
        h1 {
            font-size: 2em;
        }

        /* Override font size for contenteditable fields and summary container in mobile view */
        [contenteditable="true"],
        [contenteditable="true"] * {
            font-size: 14px !important; /* 14px for mobile */
        }

        #summary-container table th,
        #summary-container table td,
        #summary-container table th *,
        #summary-container table td * {
            font-size: 14px !important; /* 14px for mobile */
        }
    }
</style>
    
</head>
<body>
    <div class="container">
        <h1>GST Reconciliation Tool</h1>
        
        <!-- Download Sample File -->
        <a href="#" id="download-sample">Download Sample Excel File</a>

        <!-- Input for Difference Allowed -->
        <div class="input-section">
            <div>
                <label for="diff-allowed">Difference Allowed (Default: 1):</label>
                <input type="number" id="diff-allowed" value="1" min="0" placeholder="0 if blank">
            </div>
        </div>

        <!-- Upload Section -->
        <div class="upload-section">
            <div>
                <label for="gst-file">Upload GST Data File (GSTR-2B & GSTR-3B):</label>
                <input type="file" id="gst-file" accept=".xlsx">
            </div>
        </div>

        <!-- Data Display -->
        <div class="data-container">
            <h2>GSTR-2B Data</h2>
            <div id="gstr2b-container" class="table-container"></div>
            
            <h2>GSTR-3B Data</h2>
            <div id="gstr3b-container" class="table-container"></div>

            <h2>Summary</h2>
            <div id="summary-container" class="table-container"></div>
        </div>

        <!-- Reconcile Button -->
        <button id="reconcile-btn">Reconcile</button>

        <!-- Output Link -->
        <div id="output-link" style="display: none;">
            <h3>Reconciled Output:</h3>
            <a id="download-output" href="#">Download Reconciled Data</a>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/exceljs/4.3.0/exceljs.min.js"></script>
    <script>
        let gstr2bData = [];
        let gstr3bData = [];

        document.getElementById('gst-file').addEventListener('change', handleFileUpload);
        document.getElementById('reconcile-btn').addEventListener('click', reconcileData);
        document.getElementById('download-sample').addEventListener('click', generateSampleFile);

        function formatDate(excelDate) {
            if (!excelDate) return '';
            const date = new Date((excelDate - 25569) * 86400 * 1000);
            const day = String(date.getUTCDate()).padStart(2, '0');
            const month = date.toUTCString().slice(8, 11);
            const year = date.getUTCFullYear();
            return `${day}-${month}-${year}`;
        }

        const baseGstr2bHeaders = [
            'Match Criteria', 'GSTN', 'Name of Supplier', 'Invoice Number', 
            'Invoice type', 'Invoice Date', 'Invoice Value', 'Place of supply', 'Reverse Charge', 
            'Rate (%)', 'Taxable Value', 'IGST', 'CGST', 'SGST'
        ];
        const extendedGstr2bHeaders = [
            'Cess', 'GSTR-1/5 Period', 'GSTR-1/5 Filing Date', 'ITC Availability', 
            'Reason', 'Applicable % of Tax Rate', 'Source', 'IRN', 'IRN Date'
        ];
        function gstr2bHeaders() {
            return [...baseGstr2bHeaders, ...extendedGstr2bHeaders];
        }

        const baseGstr3bHeaders = [
            'Match Criteria', 'Invoice Date', 'GSTN', 'Name of Supplier', 
            'Invoice Number', 'Taxable Value', 'IGST', 'CGST', 'SGST'
        ];
        const extendedGstr3bHeaders = ['Invoice Value'];
        function gstr3bHeaders() {
            return [...baseGstr3bHeaders, ...extendedGstr3bHeaders];
        }

        function generateSampleFile(event) {
            event.preventDefault();
            const wb = XLSX.utils.book_new();

            const gstr2bSampleHeaders = gstr2bHeaders();
            const gstr2bSample = [
                gstr2bSampleHeaders,
                ['Match', '27AABCU9603R1ZM', 'Supplier A', 'INV001', 'Regular', '01-Mar-2025', 11800, 'Maharashtra', 'N', 18, 10000, 1800, 0, 0, 0, 'Mar-2025', '15-Mar-2025', 'Yes', 'N/A', 18, 'GSTR-1', 'IRN001', '02-Mar-2025'],
                ['Match', '27AABCU9603R1ZM', 'Supplier A', 'INV002', 'Regular', '01-Mar-2025', 5900, 'Maharashtra', 'N', 18, 5000, 900, 0, 0, 0, 'Mar-2025', '15-Mar-2025', 'Yes', 'N/A', 18, 'GSTR-1', 'IRN002', '02-Mar-2025'],
                ['Match', '27XYZ1234P1ZQ', 'Supplier C', 'INV003', 'Regular', '02-Mar-2025', 23600, 'Karnataka', 'N', 9, 20000, 0, 1800, 1800, 0, 'Mar-2025', '16-Mar-2025', 'No', 'Pending', 9, 'GSTR-5', 'IRN003', '03-Mar-2025']
            ];
            const ws1 = XLSX.utils.aoa_to_sheet(gstr2bSample);
            gstr2bSampleHeaders.forEach((_, index) => {
                const cell = ws1[XLSX.utils.encode_cell({ r: 0, c: index })];
                if (cell) cell.s = { fill: { fgColor: { rgb: 'E0FFFF' } } };
            });
            XLSX.utils.book_append_sheet(wb, ws1, 'GST Portal');

            const gstr3bSampleHeaders = gstr3bHeaders();
            const gstr3bSample = [
                gstr3bSampleHeaders,
                ['Match', '01-Mar-2025', '27AABCU9603R1ZM', 'Supplier A', 'INV001', 15000, 2700, 0, 0, 17700],
                ['Match', '02-Mar-2025', '27AABCU9603R1ZM', 'Supplier A', 'INV004', 6000, 1080, 0, 0, 7080]
            ];
            const ws2 = XLSX.utils.aoa_to_sheet(gstr3bSample);
            gstr3bSampleHeaders.forEach((_, index) => {
                const cell = ws2[XLSX.utils.encode_cell({ r: 0, c: index })];
                if (cell) cell.s = { fill: { fgColor: { rgb: 'E0FFFF' } } };
            });
            XLSX.utils.book_append_sheet(wb, ws2, 'Client Data');

            const wbout = XLSX.write(wb, { bookType: 'xlsx', type: 'array' });
            const blob = new Blob([wbout], { type: 'application/octet-stream' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = 'Sample_GST_Reconciliation.xlsx';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        function normalizeRow(row, headerLength) {
            const normalized = new Array(headerLength).fill('');
            row.forEach((cell, index) => {
                if (index < headerLength) normalized[index] = cell === undefined || cell === null ? '' : cell;
            });
            return normalized;
        }

        function handleFileUpload(event) {
            const file = event.target.files[0];
            const reader = new FileReader();
            reader.onload = function(e) {
                const data = new Uint8Array(e.target.result);
                const workbook = XLSX.read(data, { type: 'array', dateNF: 'dd-mmm-yyyy' });

                const gstr2bSheet = workbook.Sheets['GST Portal'];
                if (gstr2bSheet) {
                    const rawData = XLSX.utils.sheet_to_json(gstr2bSheet, { header: 1, raw: true, defval: '' });
                    gstr2bData = rawData.slice(1).map(row => normalizeRow(row, gstr2bHeaders().length));
                    displayData(gstr2bData, 'gstr2b-container', gstr2bHeaders(), 'gstr2b');
                }

                const gstr3bSheet = workbook.Sheets['Client Data'];
                if (gstr3bSheet) {
                    const rawData = XLSX.utils.sheet_to_json(gstr3bSheet, { header: 1, raw: true, defval: '' });
                    gstr3bData = rawData.slice(1).map(row => normalizeRow(row, gstr3bHeaders().length));
                    displayData(gstr3bData, 'gstr3b-container', gstr3bHeaders(), 'gstr3b');
                }

                // Initial reconciliation after upload
                reconcileData();
            };
            reader.readAsArrayBuffer(file);
        }

        function displayData(data, containerId, headers, sheetType) {
            const container = document.getElementById(containerId);
            let html = '<table><thead><tr>';
            headers.forEach(header => html += `<th>${header}</th>`);
            html += '</tr></thead><tbody>';
            data.forEach((row, rowIndex) => {
                html += `<tr data-row="${rowIndex}" data-sheet="${sheetType}">`;
                headers.forEach((_, colIndex) => {
                    const cell = row[colIndex];
                    const value = typeof cell === 'number' && (cell > 40000 && cell < 50000) ? formatDate(cell) : (cell === undefined || cell === null ? '' : cell);
                    const isEditable = colIndex > 0; // Only columns after "Match Criteria" are editable
                    html += `<td contenteditable="${isEditable}" data-col="${colIndex}">${value}</td>`;
                });
                html += '</tr>';
            });
            html += '</tbody></table>';
            container.innerHTML = html;

            // Add event listener for real-time editing
            const table = container.querySelector('table');
            table.addEventListener('input', handleCellEdit);
        }

        function handleCellEdit(event) {
            const target = event.target;
            if (target.tagName === 'TD' && target.hasAttribute('contenteditable')) {
                const rowIndex = parseInt(target.parentElement.getAttribute('data-row'), 10);
                const colIndex = parseInt(target.getAttribute('data-col'), 10);
                const sheetType = target.parentElement.getAttribute('data-sheet');
                const newValue = target.textContent.trim();

                // Update the corresponding data array
                if (sheetType === 'gstr2b') {
                    gstr2bData[rowIndex][colIndex] = newValue;
                } else if (sheetType === 'gstr3b') {
                    gstr3bData[rowIndex][colIndex] = newValue;
                }

                // Trigger real-time reconciliation
                reconcileData();
            }
        }

        function reconcileData() {
            const diffInput = document.getElementById('diff-allowed').value;
            const diffAllowed = diffInput === '' ? 0 : Number(diffInput) || 1;
            const gstr2bTable = document.querySelector('#gstr2b-container table tbody');
            const gstr3bTable = document.querySelector('#gstr3b-container table tbody');
            const reconciled2bData = [];
            const reconciled3bData = [];

            gstr2bData.forEach((row, index) => {
                const match = findMatch(row, gstr2bData, gstr3bData, false, diffAllowed);
                const newRow = [match, ...row.slice(1)];
                reconciled2bData.push(newRow);
                updateRow(gstr2bTable.rows[index], newRow);
            });

            gstr3bData.forEach((row, index) => {
                const match = findMatch(row, gstr3bData, gstr2bData, true, diffAllowed);
                const newRow = [match, ...row.slice(1)];
                reconciled3bData.push(newRow);
                updateRow(gstr3bTable.rows[index], newRow);
            });

            displaySummary(reconciled2bData, reconciled3bData);
            generateOutput(reconciled2bData, reconciled3bData);
        }

        function updateRow(rowElement, newRow) {
            const match = newRow[0];
            Array.from(rowElement.cells).forEach((cell, index) => {
                cell.textContent = newRow[index];
            });
            colorRow(rowElement, match);
        }

        function findMatch(row, sourceData, compareData, is3b, diffAllowed) {
            const sourceHeaders = is3b ? gstr3bHeaders() : gstr2bHeaders();
            const compareHeaders = is3b ? gstr2bHeaders() : gstr3bHeaders();
            const invDateIdx = sourceHeaders.indexOf('Invoice Date');
            const gstnIdx = sourceHeaders.indexOf('GSTN');
            const invNumIdx = sourceHeaders.indexOf('Invoice Number');
            const compareGstnIdx = compareHeaders.indexOf('GSTN');

            const [invDate, gstn, invNum] = [row[invDateIdx], row[gstnIdx], row[invNumIdx]];

            const sourceTotals = calculateTotals(sourceData, invDate, gstn, invNum, is3b);
            const compareTotals = calculateTotals(compareData, invDate, gstn, invNum, !is3b);
            if (sourceTotals.count > 0 && compareTotals.count > 0) {
                if (checkTotals(sourceTotals, compareTotals, diffAllowed)) {
                    return 'GSTN, Invoice No. & Date';
                }
            }

            const invTotals = calculateTotalsByInv(sourceData, gstn, invNum, is3b);
            const compareInvTotals = calculateTotalsByInv(compareData, gstn, invNum, !is3b);
            if (invTotals.count > 0 && compareInvTotals.count > 0) {
                if (checkTotals(invTotals, compareInvTotals, diffAllowed)) {
                    return 'Invoice Number';
                }
            }

            const gstnDateTotals = calculateTotalsByGstnDate(sourceData, invDate, gstn, is3b);
            const compareGstnDateTotals = calculateTotalsByGstnDate(compareData, invDate, gstn, !is3b);
            if (gstnDateTotals.count > 0 && compareGstnDateTotals.count > 0) {
                if (checkTotals(gstnDateTotals, compareGstnDateTotals, diffAllowed)) {
                    return 'GSTN & Date';
                }
            }

            const gstnTotals = calculateTotalsByGstn(sourceData, gstn, is3b);
            const compareGstnTotals = calculateTotalsByGstn(compareData, gstn, !is3b);
            if (gstnTotals.count > 0 && compareGstnTotals.count > 0) {
                if (checkTotals(gstnTotals, compareGstnTotals, diffAllowed)) {
                    return 'GSTN';
                }
            }

            const gstnExistsInCompare = compareData.some(r => r[compareGstnIdx] === gstn);
            if (!gstnExistsInCompare) {
                return 'GSTN-Not Match';
            }

            return 'Not match any creteria';
        }

        function calculateTotals(data, invDate, gstn, invNum, is3b) {
            const headers = is3b ? gstr3bHeaders() : gstr2bHeaders();
            const invDateIdx = headers.indexOf('Invoice Date');
            const gstnIdx = headers.indexOf('GSTN');
            const invNumIdx = headers.indexOf('Invoice Number');
            const taxableIdx = headers.indexOf('Taxable Value');
            const igstIdx = headers.indexOf('IGST');
            const cgstIdx = headers.indexOf('CGST');
            const sgstIdx = headers.indexOf('SGST');

            let count = 0, taxable = 0, igst = 0, cgst = 0, sgst = 0;
            data.forEach(row => {
                if (row[invDateIdx] === invDate && row[gstnIdx] === gstn && row[invNumIdx] === invNum) {
                    count++;
                    taxable += Number(row[taxableIdx]) || 0;
                    igst += Number(row[igstIdx]) || 0;
                    cgst += Number(row[cgstIdx]) || 0;
                    sgst += Number(row[sgstIdx]) || 0;
                }
            });
            return { count, taxable, igst, cgst, sgst };
        }

        function calculateTotalsByInv(data, gstn, invNum, is3b) {
            const headers = is3b ? gstr3bHeaders() : gstr2bHeaders();
            const gstnIdx = headers.indexOf('GSTN');
            const invNumIdx = headers.indexOf('Invoice Number');
            const taxableIdx = headers.indexOf('Taxable Value');
            const igstIdx = headers.indexOf('IGST');
            const cgstIdx = headers.indexOf('CGST');
            const sgstIdx = headers.indexOf('SGST');

            let count = 0, taxable = 0, igst = 0, cgst = 0, sgst = 0;
            data.forEach(row => {
                if (row[gstnIdx] === gstn && row[invNumIdx] === invNum) {
                    count++;
                    taxable += Number(row[taxableIdx]) || 0;
                    igst += Number(row[igstIdx]) || 0;
                    cgst += Number(row[cgstIdx]) || 0;
                    sgst += Number(row[sgstIdx]) || 0;
                }
            });
            return { count, taxable, igst, cgst, sgst };
        }

        function calculateTotalsByGstnDate(data, invDate, gstn, is3b) {
            const headers = is3b ? gstr3bHeaders() : gstr2bHeaders();
            const invDateIdx = headers.indexOf('Invoice Date');
            const gstnIdx = headers.indexOf('GSTN');
            const taxableIdx = headers.indexOf('Taxable Value');
            const igstIdx = headers.indexOf('IGST');
            const cgstIdx = headers.indexOf('CGST');
            const sgstIdx = headers.indexOf('SGST');

            let count = 0, taxable = 0, igst = 0, cgst = 0, sgst = 0;
            data.forEach(row => {
                if (row[invDateIdx] === invDate && row[gstnIdx] === gstn) {
                    count++;
                    taxable += Number(row[taxableIdx]) || 0;
                    igst += Number(row[igstIdx]) || 0;
                    cgst += Number(row[cgstIdx]) || 0;
                    sgst += Number(row[sgstIdx]) || 0;
                }
            });
            return { count, taxable, igst, cgst, sgst };
        }

        function calculateTotalsByGstn(data, gstn, is3b) {
            const headers = is3b ? gstr3bHeaders() : gstr2bHeaders();
            const gstnIdx = headers.indexOf('GSTN');
            const taxableIdx = headers.indexOf('Taxable Value');
            const igstIdx = headers.indexOf('IGST');
            const cgstIdx = headers.indexOf('CGST');
            const sgstIdx = headers.indexOf('SGST');

            let count = 0, taxable = 0, igst = 0, cgst = 0, sgst = 0;
            data.forEach(row => {
                if (row[gstnIdx] === gstn) {
                    count++;
                    taxable += Number(row[taxableIdx]) || 0;
                    igst += Number(row[igstIdx]) || 0;
                    cgst += Number(row[cgstIdx]) || 0;
                    sgst += Number(row[sgstIdx]) || 0;
                }
            });
            return { count, taxable, igst, cgst, sgst };
        }

        function checkTotals(source, compare, diffAllowed) {
            return Math.abs(source.taxable - compare.taxable) <= diffAllowed &&
                   Math.abs(source.igst - compare.igst) <= diffAllowed &&
                   Math.abs(source.cgst - compare.cgst) <= diffAllowed &&
                   Math.abs(source.sgst - compare.sgst) <= diffAllowed;
        }

        function colorRow(rowElement, match) {
            rowElement.className = '';
            switch (match) {
                case 'GSTN, Invoice No. & Date': rowElement.classList.add('match-gstn-inv-date'); break;
                case 'Invoice Number': rowElement.classList.add('match-inv'); break;
                case 'GSTN & Date': rowElement.classList.add('match-gstn-date'); break;
                case 'GSTN': rowElement.classList.add('match-gstn'); break;
                case 'GSTN-Not Match': rowElement.classList.add('gstn-not-match'); break;
                default: rowElement.classList.add('no-match'); break;
            }
        }

        function calculateSummary(data, is3b) {
            const headers = is3b ? gstr3bHeaders() : gstr2bHeaders();
            const taxableIdx = headers.indexOf('Taxable Value');
            const igstIdx = headers.indexOf('IGST');
            const cgstIdx = headers.indexOf('CGST');
            const sgstIdx = headers.indexOf('SGST');

            const criteria = [
                'GSTN, Invoice No. & Date', 'Invoice Number', 'GSTN & Date', 
                'GSTN', 'GSTN-Not Match', 'Not match any creteria'
            ];

            const summary = {};
            criteria.forEach(criterion => {
                summary[criterion] = { taxable: 0, igst: 0, cgst: 0, sgst: 0 };
            });

            data.forEach(row => {
                const match = row[0];
                summary[match].taxable += Number(row[taxableIdx]) || 0;
                summary[match].igst += Number(row[igstIdx]) || 0;
                summary[match].cgst += Number(row[cgstIdx]) || 0;
                summary[match].sgst += Number(row[sgstIdx]) || 0;
            });

            const total = { taxable: 0, igst: 0, cgst: 0, sgst: 0 };
            criteria.forEach(criterion => {
                total.taxable += summary[criterion].taxable;
                total.igst += summary[criterion].igst;
                total.cgst += summary[criterion].cgst;
                total.sgst += summary[criterion].sgst;
            });

            return { summary, total };
        }

        function displaySummary(reconciled2bData, reconciled3bData) {
            const gstr2bSummary = calculateSummary(reconciled2bData, false);
            const gstr3bSummary = calculateSummary(reconciled3bData, true);
            const container = document.getElementById('summary-container');

            let html = '<table><thead><tr>';
            html += '<th rowspan="2">Particulars</th>';
            html += '<th colspan="4">GST Portal</th>';
            html += '<th colspan="4">Client Data</th>';
            html += '</tr><tr>';
            ['Taxable Value', 'IGST', 'CGST', 'SGST'].forEach(header => {
                html += `<th>${header}</th>`;
            });
            ['Taxable Value', 'IGST', 'CGST', 'SGST'].forEach(header => {
                html += `<th>${header}</th>`;
            });
            html += '</tr></thead><tbody>';

            const criteria = [
                'GSTN, Invoice No. & Date', 'Invoice Number', 'GSTN & Date', 
                'GSTN', 'GSTN-Not Match', 'Not match any creteria'
            ];

            criteria.forEach(criterion => {
                html += '<tr>';
                html += `<td>${criterion}</td>`;
                html += `<td>${gstr2bSummary.summary[criterion].taxable.toFixed(2)}</td>`;
                html += `<td>${gstr2bSummary.summary[criterion].igst.toFixed(2)}</td>`;
                html += `<td>${gstr2bSummary.summary[criterion].cgst.toFixed(2)}</td>`;
                html += `<td>${gstr2bSummary.summary[criterion].sgst.toFixed(2)}</td>`;
                html += `<td>${gstr3bSummary.summary[criterion].taxable.toFixed(2)}</td>`;
                html += `<td>${gstr3bSummary.summary[criterion].igst.toFixed(2)}</td>`;
                html += `<td>${gstr3bSummary.summary[criterion].cgst.toFixed(2)}</td>`;
                html += `<td>${gstr3bSummary.summary[criterion].sgst.toFixed(2)}</td>`;
                html += '</tr>';
            });

            html += '<tr>';
            html += '<td><strong>Total</strong></td>';
            html += `<td><strong>${gstr2bSummary.total.taxable.toFixed(2)}</strong></td>`;
            html += `<td><strong>${gstr2bSummary.total.igst.toFixed(2)}</strong></td>`;
            html += `<td><strong>${gstr2bSummary.total.cgst.toFixed(2)}</strong></td>`;
            html += `<td><strong>${gstr2bSummary.total.sgst.toFixed(2)}</strong></td>`;
            html += `<td><strong>${gstr3bSummary.total.taxable.toFixed(2)}</strong></td>`;
            html += `<td><strong>${gstr3bSummary.total.igst.toFixed(2)}</strong></td>`;
            html += `<td><strong>${gstr3bSummary.total.cgst.toFixed(2)}</strong></td>`;
            html += `<td><strong>${gstr3bSummary.total.sgst.toFixed(2)}</strong></td>`;
            html += '</tr>';

            html += '</tbody></table>';
            container.innerHTML = html;
        }

        async function generateOutput(reconciled2bData, reconciled3bData) {
            const workbook = new ExcelJS.Workbook();

            const ws1 = workbook.addWorksheet('GST Portal');
            const headerRow1 = ws1.addRow(gstr2bHeaders());
            headerRow1.eachCell(cell => {
                cell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFE0FFFF' } };
            });
            reconciled2bData.forEach(row => {
                const excelRow = row.map(cell => cell === undefined || cell === null ? '' : cell);
                const addedRow = ws1.addRow(excelRow);
                applyExcelRowColor(addedRow, row[0], gstr2bHeaders().length);
            });

            const ws2 = workbook.addWorksheet('Client Data');
            const headerRow2 = ws2.addRow(gstr3bHeaders());
            headerRow2.eachCell(cell => {
                cell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFE0FFFF' } };
            });
            reconciled3bData.forEach(row => {
                const excelRow = row.map(cell => cell === undefined || cell === null ? '' : cell);
                const addedRow = ws2.addRow(excelRow);
                applyExcelRowColor(addedRow, row[0], gstr3bHeaders().length);
            });

            const ws3 = workbook.addWorksheet('Summary');
            const summaryHeader1 = ws3.addRow(['Particulars', 'GST Portal', '', '', '', 'Client Data', '', '', '']);
            const summaryHeader2 = ws3.addRow(['', 'Taxable Value', 'IGST', 'CGST', 'SGST', 'Taxable Value', 'IGST', 'CGST', 'SGST']);
            ws3.mergeCells('A1:A2');
            ws3.mergeCells('B1:E1');
            ws3.mergeCells('F1:I1');
            [summaryHeader1, summaryHeader2].forEach(row => {
                row.eachCell(cell => {
                    cell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFE0FFFF' } };
                });
            });

            const gstr2bSummary = calculateSummary(reconciled2bData, false);
            const gstr3bSummary = calculateSummary(reconciled3bData, true);
            const criteria = [
                'GSTN, Invoice No. & Date', 'Invoice Number', 'GSTN & Date', 
                'GSTN', 'GSTN-Not Match', 'Not match any creteria'
            ];

            criteria.forEach(criterion => {
                ws3.addRow([
                    criterion,
                    gstr2bSummary.summary[criterion].taxable,
                    gstr2bSummary.summary[criterion].igst,
                    gstr2bSummary.summary[criterion].cgst,
                    gstr2bSummary.summary[criterion].sgst,
                    gstr3bSummary.summary[criterion].taxable,
                    gstr3bSummary.summary[criterion].igst,
                    gstr3bSummary.summary[criterion].cgst,
                    gstr3bSummary.summary[criterion].sgst
                ]);
            });

            const totalRow = ws3.addRow([
                'Total',
                gstr2bSummary.total.taxable,
                gstr2bSummary.total.igst,
                gstr2bSummary.total.cgst,
                gstr2bSummary.total.sgst,
                gstr3bSummary.total.taxable,
                gstr3bSummary.total.igst,
                gstr3bSummary.total.cgst,
                gstr3bSummary.total.sgst
            ]);
            totalRow.eachCell(cell => {
                cell.font = { bold: true };
            });

            const buffer = await workbook.xlsx.writeBuffer();
            const blob = new Blob([buffer], { type: 'application/octet-stream' });
            const url = URL.createObjectURL(blob);
            const link = document.getElementById('download-output');
            link.href = url;
            link.download = 'Reconciled_GST_Data.xlsx';
            document.getElementById('output-link').style.display = 'block';
        }

        function applyExcelRowColor(row, match, columnCount) {
            const colors = {
                'GSTN, Invoice No. & Date': 'FF00CED1', // Teal
                'Invoice Number': 'FF4B0082',          // Indigo
                'GSTN & Date': 'FF32CD32',             // Lime Green
                'GSTN': 'FFFFBF00',                    // Amber
                'GSTN-Not Match': 'FFDC143C',          // Crimson
                'Not match any creteria': 'FFFF00FF'   // Magenta
            };
            const color = colors[match] || 'FFFF00FF';
            for (let i = 1; i <= columnCount; i++) {
                const cell = row.getCell(i);
                cell.fill = {
                    type: 'pattern',
                    pattern: 'solid',
                    fgColor: { argb: color }
                };
                if (['GSTN, Invoice No. & Date', 'Invoice Number', 'GSTN & Date', 'GSTN-Not Match', 'Not match any creteria'].includes(match)) {
                    cell.font = { color: { argb: 'FFFFFFFF' } };
                }
            }
        }
    </script>
</body>
</html>
